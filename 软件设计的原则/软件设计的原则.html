<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>软件设计的原则 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="软件设计的原则" class="main-title"></div></div></header><article><blockquote class="wolai-block"><span class="inline-wrap">面向对象 : 封装、继承、多态</span></blockquote><h2 class="wolai-block"><span class="inline-wrap"><b>背景</b></span><span class="inline-wrap"> 问题 思路</span></h2><div class="wolai-bookmark wolai-block"><a href="http://c.biancheng.net/view/1324.html">里氏替换原则——面向对象设计原则</a><div class="info-box"><div class="text-pane"><div data-title="里氏替换原则——面向对象设计原则"></div><div data-desc="在上一节 《面向对象设计原则：开闭原则》 中，我们详细介绍了开闭原则，本节我们来介绍里式替换原则。 里氏替换原则的定义 里氏替换原则（Liskov Substitution Principle，LSP）由麻省理"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://c.biancheng.net/favicon.ico?v=1.6.73&quot;)"></div><div data-hostname="c.biancheng.net"></div></div></div><div class="preview-pane"></div></div></div><h2 class="wolai-block"><span class="inline-wrap">设计原则</span></h2><h3 class="wolai-block"><span class="inline-wrap">开闭原则 OCP</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">开闭原则（Open Closed Principle，OCP）由勃兰特<span class="jill"></span>·<span class="jill"></span>梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>定义</b></span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap">软件实体应当对扩展开放，对修改关闭</span><span class="inline-wrap">（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这里的软件实体包括以下几个部分：</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">项目中划分出的模块</span></li><li><div class="marker"></div><span class="inline-wrap">类与接口</span></li><li><div class="marker"></div><span class="inline-wrap">方法</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap">作用</span></div></div><div class="red wolai-block wolai-text"><div><span class="inline-wrap">使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在面对,软件的开发维护,以及后续需求的添加,有一定的适应性和灵活性,并且之前的代码稳定,新的代码,可延续.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>实现方法</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以通过“</span><span class="red inline-wrap">抽象约束、封装变化</span><span class="inline-wrap">”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">吐槽: 这部门是指,我们所有的模块(包括方法,类,模块) 都是对扩展开房,对修改关闭.是软件设计的原则之一,是对我们创建的所有东西一种约束方式.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">单一职责</span></h3><blockquote class="wolai-block"><span class="inline-wrap">继承关系 </span></blockquote><h3 class="wolai-block"><span class="inline-wrap">里氏替换原则 LSP</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>定义</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">吐槽 :  </span></div></div><ol class="wolai-block"><li class="bg-default"><div class="marker"></div><span class="inline-wrap">也可以说是对开闭原则,</span><span class="red inline-wrap">对继承关系的一种补充</span><span class="inline-wrap">??</span></li><li><div class="marker"></div><span class="inline-wrap">所以这个替换指的是,子类能否替换成父类. 他们是不是属于一个超类的 . 比如 正方形是不是特殊的长方形,鸵鸟是不是鸟,气球鱼是不是鱼,海王是不是王.</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">接口隔离原则 ISP</span></h3><blockquote class="wolai-block"><span class="inline-wrap">关键词: 创建接口  接口隔离 最小粒度</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>定义</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2002 年罗伯特<span class="jill"></span>·C.马丁给“接口隔离原则”的定义是：</span><span class="red inline-wrap">客户端不应该被迫依赖于它不使用的方法</span><span class="inline-wrap">（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：</span><span class="red inline-wrap">一个类对另一个类的依赖应该建立在最小的接口上</span><span class="inline-wrap">（The dependency of one class to another one should depend on the smallest possible interface）。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://baike.baidu.com/item/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/3104602?fr=aladdin">接口隔离原则_百度百科</a><div class="info-box"><div class="text-pane"><div data-title="接口隔离原则_百度百科"></div><div data-desc="客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://baikebcs.bdimg.com/cms/static/baike-icon.svg&quot;)"></div><div data-hostname="baike.baidu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://bkimg.cdn.bcebos.com/smart/b7fd5266d0160924baaa50a1d20735fae7cd34f8-bkimg-process,v_1,rw_1,rh_1,pad_1,color_ffffff?x-bce-process=image/format,f_auto)"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">例子</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用场合,提供调用者需要的方法,屏蔽不需要的方法.满足接口隔离原则.比如说电子商务的系统,有订单这个类,有三个地方会使用到,</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个是用户,只能有查询方法,</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个是外部系统,有添加订单的方法,</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个是管理后台,添加删除修改查询都要用到.</span></div></div><div class="red wolai-block wolai-text"><div><span class="inline-wrap">根据接口隔离原则(ISP),一个类对另外一个类的依赖性应当是建立在最小的接口上.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">也就是说,对于用户,它只能依赖有一个查询方法的接口.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="bg-default wolai-block wolai-text"><div><span class="inline-wrap">我觉得,更像使用</span><span class="red inline-wrap">接口创建的一种限制规则(接口隔离开,其实也就是多个接口创建的规则)</span><span class="inline-wrap">.接口的粒度应该是合理的,太粗,使用者用到了不需要使用的函数,太细,继承的链路就长,难以维护. 所以一种合理的方式原则就是. </span><span class="red inline-wrap">使用者只依赖它需要的粒度的接口.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">吐槽:</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">为啥这么用,解决什么问题?</span></li></ol><div class="red wolai-block wolai-text"><div><span class="inline-wrap">创建接口的规则. 接口隔离开的规则.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">来保证接口创建的粒度合适. 这样灵活组合. 会保证,每一个类在使用的时候,使用最合适的粒度. 不会实现了不相干的函数方法(在其他概念里有其他意思)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">依赖倒置原则</span></h3><blockquote class="bg-default wolai-block"><span class="inline-wrap">关键词: 处理依赖关系 高层低层 抽象细节</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特<span class="jill"></span>·<span class="jill"></span>马丁（Robert C.Martin）于 1996 年在 </span><span class="inline-wrap"><a href="http://c.biancheng.net/cplus/"><span>C++</span></a></span><span class="inline-wrap"> Report 上发表的文章。  </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.wmyskxz.com/2019/11/18/tan-yi-tan-yi-lai-dao-zhi-yuan-ze/">谈一谈依赖倒置原则 - 我没有三颗心脏的博客</a><div class="info-box"><div class="text-pane"><div data-title="谈一谈依赖倒置原则 - 我没有三颗心脏的博客"></div><div data-desc="为获得良好的阅读体验，请访问原文：传送门"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://www.wmyskxz.com/favicon.ico&quot;)"></div><div data-hostname="www.wmyskxz.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="http://c.biancheng.net/view/1326.html">依赖倒置原则——面向对象设计原则</a><div class="info-box"><div class="text-pane"><div data-title="依赖倒置原则——面向对象设计原则"></div><div data-desc="前两节我们详细介绍了面向对象设计原则中的开闭原则和里氏替换原则，在本节中我们来介绍依赖倒置原则。 依赖倒置原则的定义 依赖倒置原则（Dependence Inversion Principle，DIP）是 Obje"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://c.biancheng.net/favicon.ico?v=1.6.73&quot;)"></div><div data-hostname="c.biancheng.net"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">例子:</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">面向过程,我学习两门课==&gt;我学习三门课. 如何变更最小的代码.  我→课   我→课程←课程内容</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>背景:</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">调用链,高层依赖于低层. 抽象依赖实现.  </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">软件开发过程中,如何处理依赖关系(类与类之间的交互)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>问题: </b></span></div></div><ol class="wolai-block"><li class="bg-default"><div class="marker"></div><span class="inline-wrap">如果是</span><span class="red inline-wrap">面向过程</span><span class="inline-wrap">的开发,上层调用下层,下层变化,上层也跟着变化.牵一发而动全身. 如果,下层被很多引用,如果下层变化,相应的关联的上层都会跟着影响,</span><span class="red inline-wrap">影响大,所以复用难度变大</span><span class="inline-wrap">.</span></li><li><div class="marker"></div><span class="inline-wrap">抽象依赖了实现,所以</span><span class="red inline-wrap">粒度越来越细,抽象越来越难被依赖</span><span class="inline-wrap">.  </span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>为什么这么做:</b></span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap">如果是面向对象开发. 如果影响这么大. 能否解耦上层下层之间的耦合?</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">增加一个新的层,让他来解决,这种依赖关系. 然后来保证,上层不依赖于下层.  ==&gt; 建立抽象层,</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">上层依赖抽象,实现也依赖抽象.</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="bg-default wolai-block wolai-text"><div><span class="red inline-wrap">吐槽</span><span class="inline-wrap">: 这个估计是编程语言设计的时候. 发现的东西,不想修改原来代码,还想复用代码,</span></div></div><div class="bg-default wolai-block wolai-text"><div><span class="inline-wrap">然后面向对象的思路,更像是人脑贴近生活,是人脑的思维方式,</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">帮我们更好的使用面向对象. 最后的效果就是.  怎么能让,</span><span class="red inline-wrap">变更影响面最小</span><span class="inline-wrap">.==&gt;减少耦合,能够复用,不影响之</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">前的. 所以添加一个抽象层,更换依赖关系.所以设计出来一个 接口/抽象 的</span><span class="red inline-wrap">语法糖.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">简而言之 : 如何处理设置合理的依赖关系,来保证我们的代码每次变更的时候,影响面更小. ==&gt;能达到可复用,</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">容易维护.  原则内容就是: 高层不依赖于底层,抽象不依赖于细节.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">合成复用原则</span></h3><blockquote class="wolai-block"><span class="inline-wrap">关键词: 复用 聚合 继承</span></blockquote><div class="bg-default wolai-block wolai-text"><div><span class="inline-wrap">合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在</span><span class="red inline-wrap">软件复用</span><span class="inline-wrap">时，要尽量先使用</span><span class="red inline-wrap">组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</span><span class="inline-wrap">。  </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="red wolai-block wolai-text"><div><span class="inline-wrap">类继承通常为“白箱复用”，对象组合则是“黑箱复用”。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://blog.csdn.net/u010832572/article/details/45007933">Java设计模式——合成/聚合复用原则_u010832572的专栏-CSDN博客_合成复用原则</a><div class="info-box"><div class="text-pane"><div data-title="Java设计模式——合成/聚合复用原则_u010832572的专栏-CSDN博客_合成复用原则"></div><div data-desc="一、什么是合成/聚合复用原则？合成/聚合复用原则是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。简述为：要尽量使用合成/聚合，尽量不要使用继承。二、合成和聚合的区别；依赖和关联合成(Composition)和聚合(Aggregation)都是关联(Association)的特殊种类。用C语言来讲，合成是值的聚合(A"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://g.csdnimg.cn/static/logo/favicon32.ico&quot;)"></div><div data-hostname="blog.csdn.net"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="http://c.biancheng.net/view/1333.html">合成复用原则——面向对象设计原则</a><div class="info-box"><div class="text-pane"><div data-title="合成复用原则——面向对象设计原则"></div><div data-desc="合成复用原则是面向对象设计原则的 7 条原则中剩下的最后一条，下面我们将对其进行详细地介绍。 合成复用原则的定义 合成复用原则（Composite Reuse Principle，CRP） 又叫 组合/聚合复用"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://c.biancheng.net/favicon.ico?v=1.6.73&quot;)"></div><div data-hostname="c.biancheng.net"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">背景:</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在面向对象设计中，可以通过两种方法在不同的环境中</span><span class="inline-wrap"><b>复用</b></span><span class="inline-wrap">已有的设计和实现，即通过</span><span class="inline-wrap"><b>组合、聚合关系</b></span><span class="inline-wrap">或者</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过</span><span class="inline-wrap"><b>继承</b></span><span class="inline-wrap">组合,聚合,这种依赖比较小. 如果是继承,需要考虑里式替换原则.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">注:并且使用继承,会破坏封装性,白箱复用,父类所有东西对</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</span></li><li><div class="marker"></div><span class="inline-wrap">子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</span></li><li><div class="marker"></div><span class="inline-wrap">它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap">采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</span></li><li><div class="marker"></div><span class="inline-wrap">新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</span></li><li><div class="marker"></div><span class="inline-wrap">复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap">例:</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">汽车有发动机,颜色,品牌,厂家,价格,等等,如果已经实现好的功能里. 比如 汽车依赖发动机,  interface<span class="jill"></span>里有 发动机的<span class="jill"></span>move 方法给她用.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果有颜色,是不是,得车加个喷漆的接口.</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image_1.png" style="width: 467.5px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">通常有这种复用关系的时候,我们应该把他放在抽象类的成员属性里.复用-&gt;聚合关系</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image_2.png" style="width: 383.5px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">应用</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">比如<span class="jill"></span>Context 类,上下文会依赖很多的类,这种复用关系,而不是放在接口里.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">迪米特原则</span></h3><blockquote class="wolai-block"><span class="inline-wrap">类依赖 暴露粒度最合适  引用粒度  只依赖朋友</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>定义</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩<span class="jill"></span>·<span class="jill"></span>荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。  </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于依赖者,我只依赖应该依赖的方法.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于被依赖者,我只提供该暴露的方法.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">==&gt; 做到最小耦合. 比如使用<span class="jill"></span>private , 不暴露没有必要的类,减少风险的发生.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">比如 老板→teamleader→程序员敲代码 敲代码的细节一定不给老板.老板只需要依赖<span class="jill"></span>teamleader  ,teamleader 是老板的&quot;朋友&quot;.  最小依赖. </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这个原则描述的是 类之间依赖关系,类内容的细节</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">应用</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">比如<span class="jill"></span>Context 类,上下文会依赖很多的类,这种复用关系,而不是放在接口里.  然后使用<span class="jill"></span>context 功能的时候,在分发给相应的类</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">思考</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">这些原则,属于优秀程序员总结出来的,原则,帮助我们更好的构建软件架构.在软件架构的时候,考虑这些原则.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">比如 开发实现工功能,创建类的时候一直得想着的开闭原则,单一职责. 复用的时候想到合成复用原则.继承,继</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">承就有里式替换原则.继承就得有接口,接口就得有接口隔离原则.在类使用其他资源的时候,就得想着,迪米特</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">原则. 目的都是为了我们的代码价值更高.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">==&gt;降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。</span></div></div><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>